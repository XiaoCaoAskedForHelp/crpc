手写RPC框架


## 注册中心优化

### 心跳检测
通过定期发动心跳包，来检测服务是否存活。

如果接受方在一定时间内没有收到心跳信号或者未能正常响应请求，就会认为目标系统故障或不可用，从而出发相应的处理和告警机制。

1）实现心跳检测2个关键：定时和网络请求

但是Etcd实现心跳检测会简单一些，因为Etcd自带了key过期机制

思路：给节点注册信息一个过期时间，让节点定期续期，重置自己的倒计时，如果如果节点已宕机，一直不续期，ETCD会对key进行过期删除

步骤：
1. 服务提供者向Etcd注册自己的服务信息，并在注册时设置TTL（生存）
2. Etcd在接受到服务提供者的注册信息后，会自动维护服务信息的TTL，并在TTL过期时删除该服务信息
3. 服务提供者定时向Etcd续期服务信息的TTL，保证服务信息不被删除

续期时间一定要小于过期时间，允许一次容错的机会

2）每个服务者都需要找到自己注册的节点、续期自己的节点，如何找到当前服务者自己的节点呢？

充分利用本地的特性，在服务提供者本地维护一个已注册节点集合，注册时添加节点key到集合中，只需要续期集合内的key即可


## 服务节点下线机制
1. 主动下线：服务提供者项目正常退出时，主动从注册中心移除注册信息
2. 被动下线： 服务提供者项目异常退出时，注册中心通过心跳检测机制，自动将服务下线（利用Etcd的key过期机制自动移除）

### 主动下线
利用JVM的ShutdownHook钩子函数，在服务关闭时，主动从注册中心移除注册信息

## 消费端服务缓存
服务节点信息列表更新频率是不高的，所以在服务消费者从注册中心获取到服务节点信息列表后，完全可以缓存到本地，不用在请求注册中心获取了，能够提高性能。

1. 增加本地缓存
用一个列表来存储服务信息即可，提供操作列表的基本方法，包括写缓存，读缓存，清空缓存等

当服务注册信息发生变更时，需要更新消费端缓存

使用Etcd的watch监听机制，当监听的某个key发生修改或删除时，就会触发时间来通知监听者

由于我们的目标是更新缓存，缓存是在服务消费端维护和使用，所以应该是服务消费端去watch

也就是说只有服务消费者执行的方法中，可以创建watch监听器，那么比较合适的位置就是服务发现方法，可以对本地获取到的所以服务节点key进行监听

需要防止重复监听同一个key，可以通过定义一个已监听key的集合来实现