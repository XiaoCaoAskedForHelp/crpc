手写RPC框架


## 注册中心优化

### 心跳检测
通过定期发动心跳包，来检测服务是否存活。

如果接受方在一定时间内没有收到心跳信号或者未能正常响应请求，就会认为目标系统故障或不可用，从而出发相应的处理和告警机制。

1）实现心跳检测2个关键：定时和网络请求

但是Etcd实现心跳检测会简单一些，因为Etcd自带了key过期机制

思路：给节点注册信息一个过期时间，让节点定期续期，重置自己的倒计时，如果如果节点已宕机，一直不续期，ETCD会对key进行过期删除

步骤：
1. 服务提供者向Etcd注册自己的服务信息，并在注册时设置TTL（生存）
2. Etcd在接受到服务提供者的注册信息后，会自动维护服务信息的TTL，并在TTL过期时删除该服务信息
3. 服务提供者定时向Etcd续期服务信息的TTL，保证服务信息不被删除

续期时间一定要小于过期时间，允许一次容错的机会

2）每个服务者都需要找到自己注册的节点、续期自己的节点，如何找到当前服务者自己的节点呢？

充分利用本地的特性，在服务提供者本地维护一个已注册节点集合，注册时添加节点key到集合中，只需要续期集合内的key即可


## 服务节点下线机制
1. 主动下线：服务提供者项目正常退出时，主动从注册中心移除注册信息
2. 被动下线： 服务提供者项目异常退出时，注册中心通过心跳检测机制，自动将服务下线（利用Etcd的key过期机制自动移除）

### 主动下线
利用JVM的ShutdownHook钩子函数，在服务关闭时，主动从注册中心移除注册信息

## 消费端服务缓存
服务节点信息列表更新频率是不高的，所以在服务消费者从注册中心获取到服务节点信息列表后，完全可以缓存到本地，不用在请求注册中心获取了，能够提高性能。

1. 增加本地缓存
用一个列表来存储服务信息即可，提供操作列表的基本方法，包括写缓存，读缓存，清空缓存等

当服务注册信息发生变更时，需要更新消费端缓存

使用Etcd的watch监听机制，当监听的某个key发生修改或删除时，就会触发时间来通知监听者

由于我们的目标是更新缓存，缓存是在服务消费端维护和使用，所以应该是服务消费端去watch

也就是说只有服务消费者执行的方法中，可以创建watch监听器，那么比较合适的位置就是服务发现方法，可以对本地获取到的所以服务节点key进行监听

需要防止重复监听同一个key，可以通过定义一个已监听key的集合来实现


## 自定义RPC协议
1. 网络传输设计
使用底层（传输层的TCP协议）性能更高
2. 消息结构设计
1）尽量使用byte字节和bit位这种更轻量的类型
2）分析消息结构，尽量减少消息体的长度
* 魔数：作用是安全校验，防止服务器处理了非框架发来的乱七八糟的消息
* 版本号：保证请求和响应的一致性
* 序列化算法：标识序列化和反序列化的算法
* 类型：标识是请求还是响应？或是心跳检测等其他用途
* 状态：如果是响应，记录响应的结果
* RequestID：请求ID，用于标识请求和响应的关联，因为TCP是双向通信的，所以需要一个标识来关联请求和响应
* 请求数据长度：保证能够完整的获取body内容信息
* 请求体：实际的请求数据
3. 消息编码器和解码器
消息结构本质上就是拼接在一起的一个字节数组，编码器先new一个空的buffer缓冲区，然后按照顺序向缓冲区依次写入这些数据，解码器在读取时也按照顺序依次读取这些数据就能还原成消息结构


# 半包和粘包
主要原因：TCP是流式协议，没有消息边界，发送端发送的数据包和接收端接收的数据包不一定是一一对应的，可能会出现半包和粘包的情况
1. 半包：发送端发送的数据包小于接收端缓冲区大小，接收端接收到的数据包不完整
2. 粘包：发送端发送的数据包大于接收端缓冲区大小，接收端接收到的数据包粘在一起

解决方案：
1. 半包：在消息头设置请求体长度，服务端接收时，判断每次消息的长度是否符合要求，不符合则不读，留到下一次接受消息的时候再读取
2. 粘包：在消息头设置请求体长度，服务端接收时，每次只读取指定长度的数据，超过长度的留着下一次接收到消息时在读取。

在Vert.x中，可以使用内置的RecordParser来解决粘包和半包问题，作用：保证下次读取到特定长度的字符

在实际运用中，消息体长度不固定，需要通过调整RecordParser的固定长度来解决
1. 先完整读取消息头信息，由于请求头信息长度是固定的，可以使用RecordParser来读取
2. 根据消息头信息中的长度字段更改RecordParser的固定长度，读取完整的消息体信息
